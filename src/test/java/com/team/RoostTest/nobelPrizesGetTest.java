// Test generated by RoostGPT for test restAssuredTest using AI Type Azure Open AI and AI Model roost-gpt4-32k

// Test generated for /nobelPrizes_get for http method type GET in rest-assured framework

// RoostTestHash=4940f5c55b

package com.team.RoostTest;

import io.restassured.RestAssured;
import io.restassured.response.Response;
import org.hamcrest.MatcherAssert;
import org.junit.*;

import java.util.*;
import java.nio.file.*;
import java.io.IOException;
import java.io.*;

import static io.restassured.RestAssured.given;
import static org.hamcrest.Matchers.*;

public class nobelPrizesGetTest {

    @Before
    public void setBaseURI() {
        RestAssured.baseURI = System.getenv("BASE_URL"); 
    }

    @Test  
    public void nobelPrizes_get_Test() throws IOException {  

        String file = "src/test/java/com/team/RoostTest/nobelPrizes_get.csv";
        
        List<String> lines = readCsvFile(file);
        assertNotNull(lines);

        for (String line : lines) {
            Map<String, String> parameters = getParamsFromLine(line);

            Response response = getNobelPrizes(parameters);  

            switch(response.statusCode()){
                case 200:
                    checkPrizes(response.jsonPath().getList("nobelPrizes"));
                    break;
                case 400:
                    validateErrorResponse(response, "Bad request.The request could not be understood by the server due to malformed syntax, modifications needed.");
                    break;
                case 404:
                    validateNotFoundResponse(response, "Not Found. The requested resource could not be found but may be available again in the future.");
                    break;
                case 422:
                    validateUnprocessableEntityResponse(response, "Unprocessable Entity. The request was well-formed but was unable to be followed due to semantic errors.");
                    break;
            }    
        }  
    }

    private List<String> readCsvFile(String filename){
        try (BufferedReader reader = Files.newBufferedReader(Paths.get(filename))) {
            String headerLine = reader.readLine();
            assertNotNull(headerLine);
            // skip the header line and return remaining lines
            return reader.lines().skip(1).collect(Collectors.toList());
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
        return null;
    }

    private Map<String, String> getParamsFromLine(String line){
        Map<String, String> map = new HashMap<>();
        String[] data = line.split(",");
        // assuming headers in the csv file as follows: "offset,limit,sort,nobelPrizeYear,yearTo,nobelPrizeCategory,format,csvLang"
        String[] headers = {"offset","limit","sort","nobelPrizeYear","yearTo","nobelPrizeCategory","format","csvLang" };
        for (int i = 0; i < headers.length; i++) {
            map.put(headers[i], data[i]);  
        } 
        return map;
    }

    private Response getNobelPrizes(Map<String, String> parameters){
        return given()
                .queryParams(parameters)
                .when()
                .get("/nobelPrizes")
                .then()
                .extract().response(); 
    }

    private void checkPrizes(List<Object> Prizes){
        for ( int i = 0; i < Prizes.size(); i++){
            MatcherAssert.assertThat("Checking nobel prize...", Prizes.get(i), instanceOf(Integer.class));
        }
    }

    private void validateErrorResponse(Response response, String message){
        MatcherAssert.assertThat("Checking error response...", response.jsonPath().get("message"), equalTo(message));
    }

    private void validateNotFoundResponse(Response response, String message){
        MatcherAssert.assertThat("Checking not found response...", response.jsonPath().get("message"), equalTo(message));
    }

    private void validateUnprocessableEntityResponse(Response response, String message){
        MatcherAssert.assertThat("Checking unprocessable entity response...", response.jsonPath().get("message"), equalTo(message));
    }
}
